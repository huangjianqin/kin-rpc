package org.kin.kinrpc.transport.grpc;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import io.grpc.*;
import io.grpc.netty.NettyChannelBuilder;
import io.grpc.netty.NettyServerBuilder;
import org.kin.framework.proxy.ProxyEnhanceUtils;
import org.kin.kinrpc.AbstractProxyProtocol;
import org.kin.kinrpc.rpc.Exporter;
import org.kin.kinrpc.rpc.Invoker;
import org.kin.kinrpc.rpc.common.Constants;
import org.kin.kinrpc.rpc.common.Url;
import org.kin.kinrpc.rpc.exception.RpcCallErrorException;
import org.kin.kinrpc.rpc.invoker.ProviderInvoker;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutionException;

/**
 * 开发流程与grpc类似, 只是底层通信和编程模型使用的是kinrpc
 * 详情: 导入kinrpc自定义.proto代码生成器, 编译, 并获取KinRpc{ServiceName}Grpc
 * 实现KinRpc{ServiceName}Grpc.XxxImplBase, 编写服务逻辑
 *
 * @author huangjianqin
 * @date 2020/12/1
 */
public class GrpcProtocol extends AbstractProxyProtocol {
    /* key -> address, value -> gRPC server */
    private static final Cache<String, GrpcServer> SERVERS = CacheBuilder.newBuilder().build();
    /* key -> address, value -> gRPC channels */
    private final ConcurrentMap<String, ReferenceCountManagedChannel> channelMap = new ConcurrentHashMap<>();

    @Override
    public <T> Exporter<T> export(ProviderInvoker<T> invoker) {
        Url url = invoker.url();
        Class<T> interfaceC = invoker.getInterface();
        String address = url.getAddress();
        //grpc server
        GrpcServer grpcServer;
        try {
            grpcServer = SERVERS.get(address, () -> {
                GrpcHandlerRegistry registry = new GrpcHandlerRegistry();

                NettyServerBuilder builder =
                        NettyServerBuilder
                                .forPort(url.getPort())
                                .fallbackHandlerRegistry(registry);
                Server server = builder.build();
                return new GrpcServer(server, registry);
            });
        } catch (ExecutionException e) {
            throw new RpcCallErrorException(e);
        }

        boolean useByteCode = Boolean.parseBoolean(url.getParam(Constants.BYTE_CODE_INVOKE_KEY));
        T proxy;
        if (useByteCode) {
            proxy = javassistProxyedProviderInvoker(invoker, interfaceC);
        } else {
            proxy = reflectProxyedProviderInvoker(invoker, interfaceC);
        }

        //获取服务实例
        T serivce = invoker.getSerivce();
        Class<?> serivceClass = serivce.getClass();
        try {
            Method method = serivceClass.getMethod("setProxiedImpl", interfaceC);
            method.invoke(serivce, proxy);
        } catch (Exception e) {
            throw new IllegalStateException("Failed to set kinrpc proxied service impl to stub, please make sure your stub " +
                    "was generated by the kinrpc-protoc-compiler.", e);
        }

        grpcServer.registry.addService((BindableService) serivce, url.getServiceKey());

        if (!grpcServer.started) {
            grpcServer.start();
        }

        return new Exporter<T>() {
            @Override
            public Invoker<T> getInvoker() {
                return invoker;
            }

            @Override
            public void unexport() {
                invoker.destroy();
                //释放无用代理类
                ProxyEnhanceUtils.detach(proxy.getClass().getName());

                grpcServer.registry.removeService(url.getServiceKey());
                //todo 尝试关闭无服务server
            }
        };
    }

    @SuppressWarnings("unchecked")
    @Override
    protected <T> T doReference(Class<T> interfaceC, Url url) {
        Class<?> enclosingClass = interfaceC.getEnclosingClass();

        if (enclosingClass == null) {
            throw new IllegalArgumentException(interfaceC.getName() + " must be declared inside protobuf generated classes, " +
                    "should be something like KinRpcServiceNameGrpc.ServiceName.");
        }

        Method kinRpcStubMethod;
        try {
            //todo 参数可能有变
            kinRpcStubMethod = enclosingClass.getDeclaredMethod("getKinRpcStub", Channel.class, CallOptions.class, Url.class);
        } catch (NoSuchMethodException e) {
            throw new IllegalArgumentException(
                    "Does not find getKinRpcStub in " +
                            enclosingClass.getName() +
                            ", please use the customized kin-rpc-transport-grpc to update the generated classes.");
        }

        //grpc Channel
        ReferenceCountManagedChannel channel = getSharedChannel(url);

        //获取stub
        try {
            //todo 参数可能有变
            return (T) kinRpcStubMethod.invoke(null,
                    channel,
                    CallOptions.DEFAULT,
                    url
            );
        } catch (IllegalAccessException | InvocationTargetException e) {
            throw new IllegalStateException("Could not create stub through reflection.", e);
        }
    }

    /**
     * 获取共用grpc channel
     */
    private ReferenceCountManagedChannel getSharedChannel(Url url) {
        String key = url.getAddress();
        ReferenceCountManagedChannel channel = channelMap.get(key);

        if (channel != null && !channel.isTerminated()) {
            channel.incrementAndGetCount();
            return channel;
        }

        synchronized (this) {
            channel = channelMap.get(key);
            // dubbo check
            if (channel != null && !channel.isTerminated()) {
                channel.incrementAndGetCount();
            } else {
                channel = new ReferenceCountManagedChannel(initChannel(url));
                channelMap.put(key, channel);
            }
        }

        return channel;
    }

    /**
     * 创建新的grpc channel
     */
    private ManagedChannel initChannel(Url url) {
        NettyChannelBuilder builder = NettyChannelBuilder.forAddress(url.getHost(), url.getPort());
        builder.disableRetry();
        return builder.build();
    }

    @Override
    protected <T> Runnable doExport(T proxyedInvoker, Class<T> interfaceC, Url url) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void destroy() {

    }

    //------------------------------------------------------------------------------------------------------------------------

    /**
     * grpc server数据封装
     */
    private class GrpcServer {
        /** grpc server */
        private final Server server;
        /** grpc 服务方法注册 */
        private final GrpcHandlerRegistry registry;
        /** server started标识 */
        private volatile boolean started;

        public GrpcServer(Server server, GrpcHandlerRegistry registry) {
            this.server = server;
            this.registry = registry;
        }

        /**
         * start
         */
        public void start() {
            try {
                started = true;
                server.start();
            } catch (IOException e) {
                throw new RpcCallErrorException(e);
            }
        }

        /**
         * shutdown
         */
        public void close() {
            //todo
            server.shutdown();
        }
    }
}
